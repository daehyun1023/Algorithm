## 백트래킹 (Backtracking)



> 모든 경우에서 중간에 조건이 만족하지 않으면 가지치기를 통해 탐색을 멈추고 다른 경우를 탐색한다.
>
> 대표적인 문제로 n-queen 문제가 있다.
>
> 원래 8*8의 체스판에서 queen 8개를 놓는 경우의 수는 $_{64}{C}_{8}$ 이고 이는 십억단위로 매우 큰 시간복잡도를 갖는다.
>
> 이를 개선하기 위해 각 행마다 8가지씩  놓는 경우인 $8^8$ 으로 줄일 수 있고, 여기서 가지치기까지 하면 8!의 시간복잡도로 구할 수 있다.

### 백트래킹 특징

- 퇴각검색
- 모든 조합을 시도해서 문제의 해를 찾는다.
- 해를 얻을 때까지 모든 가능성을 시도한다.
- 모든 가능성은 하나의 트리처럼 구성할 수 있고, 가지중에 해결책이 있다.
- 여러가지들이 존재하는 상황에서 하나의 가지를 선택
- 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
- 이런 선택을 반복하면서 최종상태에 도달한다.
- 보통 재귀 함수로 구현된다.



### 백트래킹 활용법

- 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 간다.
- 유망하다.
  - 어떤 노드를 방문했을 때 그 노드를 포함한 경로가 해답이 될수 있다면 유망하다고 한다.
- 가지치기
  - 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.





## 그리디 알고리즘

> 가장 좋을 것이라고 생각되는 아이디어를 그대로 구현하는 알고리즘, 한번 선택하면 그 선택에 후회하지 않는다!!

- 최적해를 구하는 데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy 접근이 된다.
- 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 일단, 한번 선택된 것은 **번복**하지 않는다. (**후회**하지 않는다.) 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다.