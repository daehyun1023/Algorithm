# 2021-02-25 정렬



## 버블 정렬(Bubble Sort)

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식, 시간 복잡도: O(n<sup>2</sup>)



### 정렬 과정

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.





## 카운팅 정렬(Counting Sort)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여, 선형시간에 정렬하는 효율적인 알고리즘
>
> 시간 복잡도: O(n + k), n은 정렬되어지는 리스트 길이, k는 리스트 내에서의 정수 최대값



### 제한 사항

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.



### 과정

1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장한다.
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
3. counts에서 누적합을 구한다.
4. 맨 뒤에서 부터 값(x)를 찾고, counts[x]의 값을 1 감소시켜주고 정렬되는 배열에 newArr[counts[x]]를 해준다.



## 선택 정렬 (Selection Sort)

> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
>
> 시간 복잡도: O(n<sup>2</sup>)



### 정렬 과정

- 주어진 리스트 중에서 최소값을 찾는다.
- 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
- 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.



## 병합 정렬(Merge Sort)

> 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
>
> 시간 복잡도 O(n log n)



### 분할 정복 알고리즘 활용

- 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄.
- 1/2로 계속 나누어 리스트의 크기가 1이 될때까지 리스트들로 나누고(분할), 각 리스트들을 정렬하면서 다시 합쳐나감
- top-down 방식



## 퀵 정렬(Quick Sort)

- P(피봇)값들 보다 같거나 큰 값은 오른쪽, 작은 값들은 왼쪽 집합에 위치하도록 한다.
- 피봇을 두 집학의 가운데에 위치시킨다.

